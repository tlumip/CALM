#/
#@filename tripDistribution.R
#@author Ben Stabler
#@version 1.1
#@date 5/26/04
#
#Trip Distribution (destination choice) Module
#Note: Trip distribution is calculated at the daily level
#Revised 1/27/04 benjamin.stabler@odot.state.or.us
#Revised 2/4/04  benjamin.stabler@odot.state.or.us
#Revised 3/24/04 Ben Stabler to work with lower case <income name>
#Revised 3/29/04 to work with utility function input csv file
#Revised 4/9/04 to split nhbw and nhbnw trip productions after calculating
#    trip production probability for income group based on percent of trips
#    generated by income group in trip generation.
#Revised 5/26/04 added districtScheme to allow for customize district summaries 
#Revised ~'08 a.bettinardi, made trip dist work more generically with utilities
#             Basically, allowed more matrices to be pulled in based on 
#             what's listed in distUtil.csv.  Also updated dir.create("tripdist")
#Revised 10/17/14 Martin Mann - 1_Added "inOSU" field to correctly identify all OSU zones and remove employment.  
#        The university square footage field being used assumed that employment was placed 
#        in those zones where it was actually placed in parking lots since driving trips end 
#        there and no other information was available.
#Revised 11/10/14 Martin Mann - 
#        Utility Data loads from RData file were moved after loading of current utility variable names and 
#        TripGen array. The loading was placed in a conditional control structure which loads different 
#        population data sets depending on whether the University Model  is being run.  
#        The loading included selection and loading of employment size variables and other matrix variables.
#Revised 01/21/15 Martin Mann -
#         Reorganized code for readabililty, removed unnecessary code 
#Revised 08/29/16 Martin Mann -
#         Added code in function calcDistProb to apply a k-Factor if one exists 

#See page 112 of the JEMnR User's Guide for a description.
#/

  cat("Calculate Trip Distribution\n\n")
  
    tripDistribution <- function(purpose, districtScheme=NULL) {
    
        cat(paste("Calculate ", purpose, " trip distribution\n\n", sep=""))
        
        #Create directory to store results if needed        
        if(!file.exists("tripdist")) dir.create("tripdist")
        
        ##/
        #REQUIRED FUNCTION
        #Calculate Destination Choice Utilities
        #This function calculates a utility based on the variables input in the Dist utilities for the purpose.
        #The utilities are exponentiated and NAs are replaced with zeros.
        #College Utilities with no attractions are set to zero 
        #@param distUtils - utility functions for current purpose
        #@return prob - probability for purpose
        ##/
        
        calcDistProb <- function(curDistUtils,purpose,incomes,incomeSpecificPurpose,purposeOnly,kFact) {                                        
                            #LOAD LOG SUMS                          
                            #If purpose is by income then select only the current income element of the logSum list
                            if(incomeSpecificPurpose) {                                
                                 income <- incomes[sapply(incomes, function(x) as.logical(length(grep(x,purpose))))]
                                 load(paste("access/logSum", purposeOnly, ".RData", sep=""))
                                 logSum <- get(paste("logSum", purposeOnly, sep=""))[[income]]
                                 rm(list=paste("logSum", purposeOnly, sep=""))
                            }
                            #If not income specific purpose average log sums
                            if(!incomeSpecificPurpose) {
                                 load(paste("access/logSum", purpose, ".RData", sep=""))
                                 logSum <- (get(paste("logSum", purpose, sep=""))$lowInc + get(paste("logSum", purpose, sep=""))$midInc + get(paste("logSum", purpose, sep=""))$highInc)/3
                                 rm(list=paste("logSum", purpose, sep=""))               
                            }
                            
                            #EVALUATE UTILITY AND EXPONENTIATE RESULT
                            options(warn=-1)
                            prob <- eval(parse(text=curDistUtils[purpose]))
                            if(kFact) { 
                                  if(purpose!="hbcoll") {
                                        if(file.exists("inputs/utilities/TDist_kFact.RData")){ 
                                              load("inputs/utilities/TDist_kFact.RData")
                                              prob[dimnames(TDist_kFact)[[1]],dimnames(TDist_kFact)[[2]]] <- prob[dimnames(TDist_kFact)[[1]],dimnames(TDist_kFact)[[2]]] + TDist_kFact   #added M.Mann 08/29/16
                                        }
                                  }
                            }
                            options(warn=0)
                            prob <- exp(prob)
                            prob[is.na(prob)] <- 0 
                            if(purpose=="hbcoll")  prob[,collAttr==1]<-0   #added MAM 10/09/14
                            
                            #CALCULATE PROBABILITY
                            prob <- prob/rowSums(prob) #recycle rule
                            prob[is.na(prob)] <- 0 
                            
                            #RETURN RESULT
                            return(prob)
                          }    
            
        #/
        #GET LOAD INFORMATION
        #Get variable names in distUtils,load districts and <purpose>TripProdAry
        #Also add nhbProdUtils variables to varNames if applicable purpose
        #@param distUtil - distribution utility functions
        #@param nhbProdUtils - nhb production utility functions
        #@return varNames - names of variables used in distribution
        #@return purposeOnly - purpose without income group label
        ##/         
         
        #Get names of Variables for current distribution utilities to Load
        varNames <- getVarNames(distUtils[purpose])
        if(purpose %in% c("nhbw", "nhbnw")) varNames <- unique(c(varNames, getVarNames(nhbProdUtils[purpose])))

        #Get purpose name and whether purpose is by purpose
        incomes <- c("lowInc","midInc","highInc")
        incomeSpecificPurpose <- as.logical(length(grep("lowInc|midInc|highInc", purpose)))
        purposeOnly <- purpose        
        if(incomeSpecificPurpose) purposeOnly <- gsub("lowInc|midInc|highInc", "", purpose)       
        
        #/
        #LOAD INPUTS
        #Loads inputs specified in distribution utility defintion csv file
        #Loads all the variables except logSum 
        #For "hbw" and "nhbw" with the University model, employment and household data are held in separate Rdata files    
        #RemainingEmp created by subtracting the employment of each loaded employment sector from the total employment.
        #Square footage is used to adjust up retail employment for non-work related trips       
        #/
        
        load("inputs/RData/districts.RData")
        
        #/
        #LOAD CURRENT TRIP PRODUCTION                     
        #/        

        load(paste("tripgen/", purposeOnly, "TripProdAry.RData", sep=""))
        assign("tripProdAry", get(paste(purposeOnly, "TripProdAry", sep="")))
        rm(list=paste(purposeOnly, "TripProdAry", sep=""))
        
        #/
        #LOAD EMPLOYMENT, HHS, PARK ACRES                         
        #/
        
        #Read in employment categories and subtract employment from remaining employment
        empCats <- varNames[grep("Emp",varNames)]
        isRemainingEmp <-FALSE
        if("remainingEmp"%in%varNames){
            isRemainingEmp <-TRUE
            empCats <- empCats[empCats != "remainingEmp"]
            varNames <-  varNames[varNames != "remainingEmp"]
        } 
               
        #University Model inputs
        if(purposeOnly%in%c("hbw","nhbw") & as.logical(runUniversityModel)) {               
            #Get Employment and hhs from university Rdata sets         
            curObjs <- loadListObj("inputs/SynPop_StdFacLst.RData",c("hhs","totalEmp",empCats))
            for(x in names(curObjs)) assign(x,curObjs[[x]])
            
            #Adjust retEmp and TotalEmp for sqft in shopping centers
            #if(exists("retEmp")) {
            #    load("inputs/RData/shsqft.RData")
            #    shemp <- shsqft / 1000 * shopEmpFactor
            #    if(exists("totalEmp")) totalEmp <- totalEmp - retEmp
            #    retEmp <- (retEmp * (retEmp >= shemp) + shemp * (retEmp < shemp))
            #    if(exists("totalEmp")) totalEmp <- totalEmp + retEmp
            #}
                          
            #Create Remaining Emp Matrix
            if(isRemainingEmp) remainingEmp <-  matrix(totalEmp, length(totalEmp), length(totalEmp), byrow=T) 
                
            #Create Employment Matrices and subtract employment from remaining employment
            for(emp in empCats) {
                assign(emp, matrix(get(emp), length(get(emp)), length(get(emp)), byrow=T))
                if(isRemainingEmp) remainingEmp <- remainingEmp - get(emp)
            }
            #create hhs matrix for nhbw
            if(purposeOnly%in%"nhbw") hhs <- matrix(hhs, length(hhs), length(hhs), byrow=T)
                       
        }else{          
        #Non-University Model inputs                          
            #Get Employment
            load(paste("inputs/RData/totalEmp.RData", sep=""))
            for(emp in empCats) load(paste("inputs/RData/", emp, ".RData", sep="")) 
              
            #Adjust retEmp and TotalEmp for sqft in shopping centers
            if(exists("retEmp")) {
                load("inputs/RData/shsqft.RData")
                shemp <- shsqft / 1000 * shopEmpFactor
                if(exists("totalEmp")) totalEmp <- totalEmp - retEmp
                retEmp <- (retEmp * (retEmp >= shemp) + shemp * (retEmp < shemp))
                if(exists("totalEmp")) totalEmp <- totalEmp + retEmp
            }
              
            #Create employment matrices and adjust remaining employment matrix is required  
            if(isRemainingEmp) remainingEmp <- matrix(totalEmp, length(totalEmp), length(totalEmp), byrow=T)            
            for(emp in empCats) {          
                assign(emp, matrix(get(emp), length(get(emp)), length(get(emp)), byrow=T))
                if(isRemainingEmp)remainingEmp <- remainingEmp - get(emp)
            }    
                            
            #Determine remaining Variables (non Employment) and load
            varsToLoad <- varNames[!varNames%in%c(empCats,"logSum","collAttr")] 
            for(vars in varsToLoad) {
                load(paste("inputs/RData/", vars, ".RData", sep=""))
                if(is.vector(get(vars))) {
                    assign(vars, matrix(get(vars), length(get(vars)), length(get(vars)), byrow=T))
                }
            }      
        }

        #/
        #LOAD COLLEGE ATTRACTIONS                         
        #/
        
        #Replicate by row to create full matrix when RData input read in is a vector. 
        #@param hbcollAttractions - college vehicle trips From Trip Gen 
        #@return collAttr - college attractions    
        #Load hbcoll attractions if purpose is hbcoll
        if(purpose == "hbcoll") {
             load("tripgen/hbcollAttractions.RData")
             collAttr <- hbcollAttractions   	    
             #Replace 0 college attractions with 1 since they are logged
             collAttr[collAttr == 0] <- 1
             rm(hbcollAttractions)
        }

        #/
        #LOAD LOGSUMS                         
        #/        
        #These are loaded in the calcDistProb function

        ##/
        #GET TRIP PRODUCTIONS AND COLLAPSE TO INCOME
        #@param tripProdAry - trip production array for purpose
        #@return lowIncProd - lowInc productions by zone
        #@return midIncProd - midInc productions by zone
        #@return highIncProd - highInc productions by zone
        ##/
    
        #Collapse tripProdAry to total productions by zone and by income if applicable purpose
        productions <- apply(tripProdAry, c(3,5), sum)
        lowIncProd <- productions["i1",] + productions["i2",]
        midIncProd <- productions["i3",]
        highIncProd <- productions["i4",]
        
        ##/
        #CALCULATE NHBW AND NHBNW PRODUCTION PROBABILITES
        #Calculate nhbw and nhbnw productions if purpose == nhbw or nhbnw
        #Sum total model area productions for nhbw and nhbnw then, multiply total productions by the zonal production probabilities to get productions by zone              
        #@param tripProdAry - trip production array for purpose
        #@return lowIncProd - lowInc productions by zone
        #@return midIncProd - midInc productions by zone
        #@return highIncProd - highInc productions by zone
        ##/        
                
        #For nhbw and nhbnw calculate production probabilities 
        if(purpose %in% c("nhbw", "nhbnw")) {           
            #Get total productions (not disaggregated by income class for nhbw and nhbnw)
            totalProductions <- sum(tripProdAry)
           
            #Calculate nhbw and nhbnw production utilities
            prodUtil <- calcDistProb(nhbProdUtils, purpose, incomes, incomeSpecificPurpose, purposeOnly, kFact=F)
            prodUtil <- prodUtil[1,] #Only need row one since prod util is one dimensional
            prodProb <- prodUtil/sum(prodUtil)
            prodProb[is.infinite(prodProb)] <- 0 #Set result of divide by zero to zero
         
            #Calculate total productions for each zone and split into incomes groups based on trip productions by market segment in trip generation
            prod <- prodProb * totalProductions     
            lowIncProd <- prod * sum(lowIncProd)/sum(productions)
            midIncProd <- prod * sum(midIncProd)/sum(productions)
            highIncProd <- prod * sum(highIncProd)/sum(productions)
            rm(prod, prodProb, totalProductions)
         }
                
        ##/
        #DISTRIBUTE TRIPS BY INCOOME AND CREATE A DISTRICT REPORT
        #Multiply productions by distribution probabilities
        #If hbw or hbcoll save raw distributions to RData files for balancing.
        #If the purpose input to tripDist is actually an income specific purpose such as hbwlowInc then only distribute trips for that income
        #@param incomeSpecificPurpose - if purpose is income specific
        #@param <various> - depends on utility function
        #@param distUtils - utility functions
        #@param lowIncProd - lowInc productions by zone
        #@param midIncProd - midInc productions by zone
        #@param highIncProd - highInc productions by zone
        #@param purposeOnly - purpose without income group label
        #@param districtScheme - district scheme column label for reporting
        #@return <purpose><income>Dist - <purpose><income> trip distribution
        ##/ 
        
        if(incomeSpecificPurpose) {
            #Get income and create variable names
            income <- strsplit(purpose, purposeOnly)[[1]][2]
            curDistMat <- paste(purposeOnly, income, "Dist", sep="")
            curProdMat <- paste(income, "Prod", sep="")
            
            #Calculate purpose distribution probability matrix
            distProb <- calcDistProb(distUtils, purpose, incomes, incomeSpecificPurpose, purposeOnly, kFact=T)
            
            #Multiply productions by distribution probabilities
            assign(curDistMat, get(curProdMat) * distProb)
            #print(table(round(rowSums(get(curDistMat)),0))) 
             
            #Save
            save(list=curDistMat, file=paste("tripdist/", curDistMat,".RData", sep=""))
            
            #Report
            if(!is.null(districtScheme)) {
                Desc <- paste(purposeOnly, " distribution - ", income, sep="")
                RptName <-  paste("tripdist/", purposeOnly, "dist", sep="")
                distsum(curDistMat, Desc, districtScheme, 3, RptName, project, initials, districts)
            }
             
            rm(list=c("distProb",curProdMat,curDistMat))
        }
        
        if(!incomeSpecificPurpose) {       
            for(income in c("lowInc", "midInc", "highInc")) {                  
                #Get income and create variable names
                curDistMat <- paste(purposeOnly, income, "Dist", sep="")
                curProdNMat <- paste(income, "Prod", sep="")
                  
                #Calculate purpose distribution probability matrix
                distProb <- calcDistProb(distUtils, purpose, incomes, incomeSpecificPurpose, purposeOnly, kFact=T)
                  
                #Multiply productions by distribution probabilities
                assign(curDistMat, get(curProdNMat) * distProb)
                #print(table(round(rowSums(get(curDistMat)),0)))  
                
                #Save                
                save(list=curDistMat, file=paste("tripdist/",curDistMat,".RData", sep=""))
                  
                #Report
                if(!is.null(districtScheme)) {
                    Desc <- paste(purposeOnly, " distribution - ", income, sep="")
                    RptName <-  paste("tripdist/", purposeOnly, "dist", sep="")
                    distsum(curDistMat, Desc, districtScheme, 3, RptName, project, initials, districts)
                }
                
                rm(list=c("distProb",curProdNMat,curDistMat))
            }  
        }
        rm(list=c(empCats))
        ##/      
        #REMOVE UNIVERSITY OBJECTS IF REQUIRED
        ##/
        
        if(purposeOnly%in%c("hbw","nhbw") & as.logical(runUniversityModel)) rm(list=names(curObjs)[!names(curObjs)%in%empCats])         

        
        cat(paste("Finished with Calculate ", purpose, " trip distribution\n\n", sep=""))
    } 
    
########################################## END #################################################################